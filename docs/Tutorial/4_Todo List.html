<h1>Todo List</h1><p>At this point we are going to start building a simple application to demonstrate some basic QCMagritte functionality and introduce you to more Smalltalk and Pharo as we go along. The application will allow you to maintain a simple todo list, that allows new items to be added and existing items to be &quot;completed&quot;. Instead of starting with a user interface, we will start with a domain model that holds a todo item.</p><h2>Todo item</h2><p>Start the QCMagritte One-Click Experience and in the System Browser click on an item in the first column to get a new class-creation template. Edit the template to match the following and save the text.</p><div><p class="code">QCObject subclass: #TodoItem<br/>	instanceVariableNames: 'title description completed'<br/>	classVariableNames:''<br/>	category:'Tutorial-Model'<br/></p><p>This creates a new subclass of QCObject named &quot;TodoItem&quot;, gives it three instance variabes (&quot;title&quot;, &quot;description&quot; and &quot;completed&quot;) and puts it in the &quot;Tutorial-Model&quot; category.<br/></p></div><h2>Accessors</h2><p>Next we will define a couple of‘accessor (or‘getter) methods that simply return the value of the instance variable. (The method return is signaled by the up arrow or caret at the beginning of an expression.) These methods are necessary because in proper Smalltalk there is no direct structural access to the instance variables (or properties or fields) of an object. This language design enforces encapsulation and allows the implementation of an object to change (perhaps the ‘price’ is calculated every time it is requested rather than saved with the object). Note that these are two separate methods.</p><div><p>To get to a method creation template, click on ‘Todo-List-Model’ in the first column, click on ‘TodoItem’ in the second column, click on ‘-- all --‘ in the third column, click in the text area at the bottom of the system browser, and finally select all using &lt;Ctrl&gt;+&lt;A&gt; (or click in the text area after the end of the last line). Enter the first method (two lines), save (using &lt;Ctrl&gt;+&lt;S&gt;), and then select all, delete, and enter the second method (two lines), and save.<br/></p><p class="code">title<br/>	^title<br/></p><p class="code">description<br/>	^description<br/></p><p class="code">completed<br/>	^completed ifNil: [ false ]<br/></p><p>When an instance variable is not initialized it is nil by default. We send the message &quot;ifNil:&quot; to this variable, and if this variable is nil the block that is passed is evaluated. Evaluation gives the result false. If the variable is something else, the message &quot;ifNil:&quot; returns the variable itself.<br/></p></div><h2>Setters</h2><p>Next we will define the setters’that store the value in the instance variable. As documentation we will put the name of the expected type in the variable name</p><div><p class="code">title: aString<br/>	title := aString<br/></p><p class="code">description: aString<br/>	^description := aString<br/></p><p class="code">completed: aBoolean<br/>	completed := aBoolean<br/></p></div><h2>Descriptions</h2><p>Now that we can access our variables properly we need to add descriptions to our class. These descriptions will be marked with a &quot;pragma&quot; (annotation) that allows the framework to recognize these methods. The syntax for a pragma is &quot;&lt;&quot; the annotation &quot;&gt;&quot;</p><div><p class="code">descriptionTitle<br/>	&lt;magritteDescription&gt;<br/>	^MAStringDescription new<br/>		accessor: #title;<br/>		label: 'Title';<br/>		priority: 100;<br/>		beRequired;<br/>		yourself<br/></p><p>We state here that the title has a type of String. The accessor links it to the getter &quot;title&quot; and setter &quot;title:&quot;. The label is shown to the user in front of the field, to make it recognizable. Finally the priority determines the order in which the fields are shown. We use 100 by default for the first item to be shown. Also we indicate that the title is a required field and should be filled out by the user.<br/></p><p class="code">descriptionDescription<br/>	&lt;magritteDescription&gt;<br/>	^MAMemoDescription new<br/>		accessor: #description;<br/>		label: 'Description';<br/>		priority: 200;<br/>		yourself<br/></p><p>A Memo is a longer string. Since different components should be used to display and edit long strings, for magritte this is considered a different type.<br/></p><p class="code">descriptionCompleted<br/>	&lt;magritteDescription&gt;<br/>	^MABooleanDescription new<br/>		accessor: #completed;<br/>		label: 'Completed';<br/>		priority: 300;<br/>		yourself<br/></p><p>Finally, our completed variable is of type boolean. It can either be true or false.<br/></p></div><h2>Model</h2><p>We now have a class that we can show. We need to put this class into a model. The model will be a single access point for the application where all objects are stored. As we use the Bootstrap template, we will use QCBootstrapApplicationModel as our base class for our model</p><div><p class="code">QCBootstrapApplicationModel subclass: #TodoListModel<br/>	instanceVariableNames: 'todoItems'<br/>	classVariableNames: ''<br/>	category: 'Tutorial-Model'<br/></p><p>For the todoListItems we also create a getter and a setter.<br/></p><p class="code">todoItems<br/>	^todoItems ifNil: [ todoItems := OrderedCollection new ]<br/></p><p>Note that we need to initialize the todoItems so we can add items to it.<br/></p><p class="code">todoItems: aCollection<br/>	todoItems := aCollection<br/></p></div><h2>Items Description</h2><p>Also, for our model we need to create a description for the todo list items. In our description we will link it to our class we created at the beginning of this chapter.</p><div><p class="code">descriptionTodoItems<br/>	&lt;magritteDescription&gt;<br/>	^MAToManyRelationDescription new<br/>		label: 'Todo';<br/>		accessor: #todoItems;<br/>		priority: 200;<br/>		classes: { TodoItem };<br/>		yourself<br/></p><p>The type of the todo list is a &quot;to many relation&quot; to the classes &quot;TodoItem&quot;. Note that the &quot;{&quot; &quot;}&quot; creates an array of the things that are listed in between.<br/></p></div><h2>Link to application</h2><p>Finally we need to link our model to the application. As this is simply a demo, we will bind it to the Welcome application we already have made. Here we override the &quot;model&quot; method.</p><div><p class="code">model<br/>	^TodoListModel default<br/></p><p>In QCApplicationModel we have defined a class variable &quot;default&quot;. This class variable is created once for all subclasses. We use this class variable as our singleton, so we can access our model from all sessions.<br/></p></div><h2>First version</h2><p>Now we can check to see if our website is working. Go to &quot;Hello World&quot; in the browser and press reload. It should add &quot;Todo&quot; in the menu, and since this is the first item, automatically select it.</p><div><p>You should see the following screen:<br/></p><p>Now we are going to test this application by adding some todo items. Just fill them out however you like.<br/></p><p>Note that the user can double-click an item to edit this item inline in the report (same as the edit-button). Also adding will simply &quot;add&quot; the items, and removing will need a confirmation before the remove is actually committed. So the user can always undo his action quite easily.<br/></p><p>Also there is a button where we can go to the details. This will open a new page where you can edit the item as well.<br/></p></div><h2>Display name</h2><p>When you click on the details of an item, it opens a new page. But the title of this page is still a bit silly: it states: &quot;a TodoItem&quot;. This is because  in smalltalk the default &quot;toString&quot; implementation provides us with this. We want to change this name into the title.</p><div><p>In the framework it suffices to change the displayName. This will change all strings that are for the user visible. We add the following method to TodoItem.<br/></p><p class="code">displayName<br/>	^self title ifNil: [ 'New item' ]<br/></p><p>We could have simply used &quot;^title&quot;. We believe this is not a good practice, as we could later add a &quot;lazy&quot; initialization of the title. We therefore use &quot;self title&quot;, such that any code we put in the accessor method (title) will be triggered. We also add a default, that is used when the title is not set.<br/></p><p>When you go back to the website you can simply reload the page. It will automatically update the title of the page. This also means that when the title of a todo item changes, this will also be reflected in the page title.<br/></p></div><h2>Completed</h2><p>From the perspective of the user, the column completed is a bit odd. We can add items that are already completed, and simply check this box. We should do something about this.</p><div><p>First of all we are going to disallow the user to change this value by hand. We are going to make this column readonly. We do this by adding the message: &quot;beReadonly&quot; in the cascade of the description readonly. This method should look like this after editing:<br/></p><p class="code">descriptionCompleted<br/>	&lt;magritteDescription&gt;<br/>	^MABooleanDescription new<br/>		accessor: #completed;<br/>		label: 'Completed';<br/>		priority: 300;<br/>		beReadonly;<br/>		yourself<br/></p><p>But we still want to be able to complete a todo item. We do this by adding actions to the todo item. We add the following method:<br/></p><p class="code">containerActions: aContainer<br/>	&lt;magritteContainer&gt;<br/>	^aContainer<br/>		addCommand: 'Complete' action: #complete;<br/>		addCommand: 'Reopen' action: #reopen;<br/>		yourself<br/></p><p>Here we see a new pragma: &quot;magritteContainer&quot;. Because the method has a parameter it indicates it should be called with the container that is created. It is called before we add our descriptions. Here we add our commands.<br/></p><p>There is a second special thing here we want to note: #complete is a symbol. This is a constant in Smalltalk. In Smalltalk we can use these symbols to call methods on objects.<br/></p><p>The command here means that the method complete will be called when the user presses on the action &quot;complete&quot;, that is both visible in the overview and the details. This means we need to implement these methods as well:<br/></p><p class="code">complete<br/>	completed := true<br/></p><p class="code">reopen<br/>	completed := false<br/></p><p>Go back to the website and test how this looks. There is a good chance that reloading won't change a thing, because the component is already initialized with the magritte-description. We will go into the technical about this later, for now: if the webpage has not changed, press the &quot;new session&quot; button on the bottom left.<br/></p></div><h2>Conditions</h2><p>Now we have links to complete and reopen an item, but this still is a bit awkward. The links are shown always, independant of the state.</p><div><p>We are going to add a condition to the commands. This is quite simple as we only need to fill out the parameter for this.<br/></p><p class="code">containerActions: aContainer<br/>	&lt;magritteContainer&gt;<br/>	^aContainer<br/>		addCommand: 'Complete' condition: #notComplete action: #complete;<br/>		addCommand: 'Reopen' condition: #isComplete action: #reopen;<br/>		yourself<br/></p><p>Of course we need to implement the two method's that are referenced here too.<br/></p><p class="code">isComplete<br/>	^self completed<br/></p><p class="code">notComplete<br/>	^self completed not<br/></p><p>Save these methods and go back to the website and see the changes. Since we always edit the descriptions, and the description methods are called on creation of the components, we need a new component to actually see these changes. A new session will start everything new, so it will create a new component. As we proceed, you will notice that for some changes you only have to refresh the page, while for others you will need a new session. Keep this in mind when developing your application.<br/></p></div><h2>Open items</h2><p>Finally we are going to make one last change to complete this chapter.</p><div><p>We are going to add a second description to our model. Instead of showing all todo items, we only want to show the incomplete todo items. Since this method looks very much like our first description, we first select the description. First we are going to save this as a different method by changing the first line into: &quot;descriptionOpenItems&quot;, and then save.<br/></p><p>By saving the same method under a different name, we automatically have a copy of the method. Now we change the accessor of this copy into: #openItems&quot;, set the priority into 100 and the label to &quot;Open todo's&quot;. The result should look like this:<br/></p><p class="code">descriptionOpenItems<br/>	&lt;magritteDescription&gt;<br/>	^MAToManyRelationDescription new<br/>		label: 'Open items';<br/>		accessor: #openItems;<br/>		priority: 100;<br/>		classes: { TodoItem };<br/>		yourself<br/></p><p>In the original method we change the label into: &quot;All items&quot; and the priority into 200. Finally we need to implement the new accessors.<br/></p><p class="code">openItems<br/>	^self todoItems select: [ :each | each notComplete ]<br/></p><p>The &quot;select:&quot; method returns a collection with only the items for those the block will evaluate to &quot;true&quot;.<br/></p><p class="code">openItems: aCollection<br/>	self openItems do: [ :each |<br/>		(aCollection includes: each) ifFalse: [ self todoItems remove: each ] ].<br/>	aCollection do: [ :each |<br/>		(self todoItems includes: each) ifFalse: [ self todoItems add: each ] ]<br/></p><p>When you edit a collection in Magritte, Magritte assigns the whole collection to the object after the change. So you will not notice any individual add or remove actions. So we need to implement here the difference. First we check for all removals, then we check for all new items.<br/></p></div><h2>Open items</h2><p>When all went successfull there are now two menu items: one showing the todo list, and one showing all items, including the items that are completed. When you press the button completed, it should be removed from the todolist; and re-opening an item should add it to the todolist.</p><div><p>Save and quit the image and proceed with the next chapter.<br/></p></div>